parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"X8yI":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var e=t(require("react")),o=require("../../scripts/components");function n(e){if("function"!=typeof WeakMap)return null;var o=new WeakMap,t=new WeakMap;return(n=function(e){return e?t:o})(e)}function t(e,o){if(!o&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=n(o);if(t&&t.has(e))return t.get(e);var a={},s=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var r in e)if("default"!==r&&Object.prototype.hasOwnProperty.call(e,r)){var i=s?Object.getOwnPropertyDescriptor(e,r):null;i&&(i.get||i.set)?Object.defineProperty(a,r,i):a[r]=e[r]}return a.default=e,t&&t.set(e,a),a}var a="https://github.com/AngleSharp/anglesharp.github.io/tree/main/docs/tutorials/05-Migration.md",s='\n<h1 id="migration-guide">Migration Guide</h1>\n<h2 id="0.12-to-0.13">0.12 to 0.13</h2>\n<h3 id="task-event-loop">Task Event Loop</h3>\n<p>The default event loop has been moved out of AngleSharp. You\'ll find an event loop implementation in <code>AngleSharp.Js</code>, however, in most cases you\'ll need care unless you directly required it for some reason (unlikely).</p>\n<h3 id="cookies">Cookies</h3>\n<p>To better utilize cookies the provided functionality from <code>AngleSharp.Io</code> has been named <code>WithCookies</code>. To avoid a naming conflict the default implementation is now called <code> WithDefaultCookies</code>, just like other <code>WithDefault...</code> methods.</p>\n<p>If you use the existing <code>WithCookies</code> helper then either also install the <code>AngleSharp.Io</code> package (the contained cookie container is much better!) or rename your configuration set up of cookies to <code>WithDefaultCookies</code>.</p>\n<h3 id="asynchronous-events">Asynchronous Events</h3>\n<p>Most events in the DOM are actually asynchronous. This was previously not correctly implemented. If you use events from C# you\'ll potentially need to await them now properly. In most cases you\'ll not feel any difference though.</p>\n<h2 id="0.11-to-0.12">0.11 to 0.12</h2>\n<p>For this change we do not expect any migration work unless a custom implementation of <code>IElement</code> has been done (unlikely).</p>\n<h2 id="0.10-to-0.11">0.10 to 0.11</h2>\n<p>This release follows the spirit of 0.10 an prepares for the 1.0 later this year. There are mainly additions, but also one important breaking change: We removed everything that is related to AngleSharp.Xml. This is now part of separate library called AngleSharp.Xml.</p>\n<h3 id="svg">SVG</h3>\n<p>The <code>ISvgDocument</code> interface and its implementation <code>SvgDocument</code> have been removed. They are now available via the <code>AngleSharp.Xml</code> library. There should be no need to access these types directly - in most cases <code>IDocument</code> should be more than sufficient.</p>\n<h3 id="xml">XML</h3>\n<p>The full <code>AngleSharp.Xml</code> namespace has been moved to a dedicated library with the same name.</p>\n<h3 id="xhtml">XHTML</h3>\n<p>As with XML also XHTML has been mostly removed. This is not a big change though. It only impacts the <code>AutoSelectedMarkupFormatter</code>, which is now part of the AngleSharp.Xml library. Furthermore, it moved from <code>AngleSharp.Xhtml</code> to the <code>AngleSharp.Xml</code> namespace.</p>\n<h3 id="peer-dependencies">Peer Dependencies</h3>\n<p>The peer dependency to the System.Encoding.CodePages package for the .NET Framework release is gone. This is now also a dependency for the .NET Framework target.</p>\n<h2 id="0.9.x-to-0.10-(or-later)">0.9.x to 0.10 (or later)</h2>\n<p>The v0.10 release line of AngleSharp is breaking towards formerly used APIs. Even though the same concepts are mostly applied, many things changed and an upgrade from AngleSharp pre v0.10 to 0.10 will certainly break things. The following points should help you to perform the migration as fast as possible.</p>\n<p>In the following points the v0.10 release line will be named &quot;current&quot;, while older releases will be referred to as &quot;previous&quot;.</p>\n<h3 id="silverlight-%2F-pre-.net-4.5">Silverlight / Pre .NET 4.5</h3>\n<p>:warn: These platforms are no longer support. No solution planned.</p>\n<blockquote>\n<p>Recommendation: Stay at AngleSharp pre-v0.10 for the moment. Sorry for inconvenience!</p>\n</blockquote>\n<h3 id="configuration">Configuration</h3>\n<p>The way to configure AngleSharp was changed. Earlier, the provided configuration was simply referenced by, e.g., the <code>BrowsingContext</code>. Now upon creation the browsing context is doing some evaluation and creates its own copy of the configuration. Thus a configuration can also be seen as a (re-)usable draft for what will become the options to be considered from a browsing context.</p>\n<p>The extension methods for working with an <code>IConfiguration</code> type of object changed. Along the standard <code>With</code> we now also have</p>\n<ul>\n<li><code>WithOnly</code>, which will remove earlier occurances of the same type and</li>\n<li><code>Without</code>, which will drop any existing occurance of the given type.</li>\n</ul>\n<p>Additionally, besides the overloads using a plain object and a specific type of service, we also got a creator overload. This overload features a function <code>Func&lt;IBrowsingContext, T&gt;</code> (with <code>T</code> being the type of the service) to be used once the configuration is used by a browsing context.</p>\n<p>The default configuration extenders remained the same (such as <code>WithDefaultLoader</code>), however, their arguments may have changed. In case of <code>WithDefaultLoader</code> you need to supply an object instead of using a callback. Commonly, instead of doing</p>\n<pre><code class="hljs language-cs">config.WithDefaultLoader(setup =&gt; setup.IsResourceLoadingEnabled = <span class="hljs-literal">true</span>)\n</code></pre>\n<p>you now have to write</p>\n<pre><code class="hljs language-cs">config.WithDefaultLoader(<span class="hljs-keyword">new</span> LoaderOptions { IsResourceLoadingEnabled = <span class="hljs-literal">true</span> })\n</code></pre>\n<h3 id="html">HTML</h3>\n<p>The unified parser interface has been changed. It is no longer possible to call <code>Parse</code>, instead this is now <code>ParseDocument</code>. Hence some old code like</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">var</span> htmlDocument = parser.Parse(<span class="hljs-string">&quot;&quot;</span>);\n</code></pre>\n<p>is now</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">var</span> htmlDocument = parser.ParseDocument(<span class="hljs-string">&quot;&quot;</span>);\n</code></pre>\n<p>Note: Same applies to the <code>Async</code> parsing (which is still recommended). Here we now have <code>ParseDocumentAsync</code>.</p>\n<p>Also the <code>HtmlParser</code> does no longer accept an <code>IConfiguration</code> in the constructor. In this case we implicitly created an <code>BrowsingContext</code>, which we want to avoid to show the user what is really happening. Instead, a browsing context should be passed in now.</p>\n<p>The following old code</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">var</span> parser = <span class="hljs-keyword">new</span> HtmlParser(Configuration.Default);\n</code></pre>\n<p>is therefore to be replaced with</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">var</span> context = BrowsingContext.New(Configuration.Default);\n<span class="hljs-keyword">var</span> parser = <span class="hljs-keyword">new</span> HtmlParser(context);\n</code></pre>\n<h3 id="css">CSS</h3>\n<p>The current version of AngleSharp split out the CSS parsing (except CSS selectors) in its own library. This library is called <code>AngleSharp.Css</code> and is available via NuGet.</p>\n<p>The new library is much more feature rich than the old integration. Besides an improved object model (CSSOM and beyond) we included support for many things, e.g., CSS custom properties (also known as CSS variables), flexbox, and grid. The correctness tests of the used value conversions have been extended as well.</p>\n<p>The basic usage is to configure AngleSharp using <code>WithCss</code>. Then, e.g., the style can be accessed by using <code>GetStyle</code> from <code>AngleSharp.Css.Dom</code>. Setting the style works now with the <code>SetStyle</code> extension method. This replaces the old <code>Style</code> property.</p>\n<p>The <code>ICssStyleDeclaration</code> does not contain all known declarations as properties. Instead, extension methods are used to dynamically attach these getters and setters, e.g., <code>GetDisplay()</code> and <code>SetDisplay(value)</code>  instead of <code>Display { get; set; }</code>.</p>\n<p>Therefore the following old code won\'t work any more:</p>\n<pre><code class="hljs language-cs">((IHtmlElement)element).Style.Display = <span class="hljs-string">&quot;flex&quot;</span>;\n</code></pre>\n<p>Instead we now have to use the AngleSharp.Css NuGet package, which should be used in the configuration like <code>Configuration.Default.WithCss()</code>. If all this is fulfilled the following extension method will work:</p>\n<pre><code class="hljs language-cs">((IHtmlElement)element).Style.SetDisplay(<span class="hljs-string">&quot;flex&quot;</span>);\n</code></pre>\n<p>In previous versions the <code>IWindow</code> also contained CSS methods for style computation. These are now also available in the new CSS library as extension methods. The <code>WindowExtensions</code> are contained in the namespace <code>AngleSharp.Dom</code>.</p>\n<h3 id="building-query-selectors">Building Query Selectors</h3>\n<p>In AngleSharp v0.9 we can construct an <code>ISelector</code> directly like:</p>\n<pre><code class="hljs language-cs">CssParser parser = <span class="hljs-keyword">new</span> CssParser();\nISelector selector = parser.ParseSelector(<span class="hljs-string">&quot;p &gt; a&quot;</span>);\n</code></pre>\n<p>Starting with AngleSharp v0.10 such direct access should be avoided. The <code>CssParser</code> is gone anyway and exists only in a reduced form within AngleSharp.Core (no CSS support), which implements the <code>ICssSelectorParser</code> interface.</p>\n<p>The current way for accessing this functionality is via the service collection.</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">var</span> config = Configuration.Default;\n\n<span class="hljs-comment">// use the consuming (or a new) context</span>\n<span class="hljs-keyword">var</span> context = BrowsingContext.New(config);\n\n<span class="hljs-comment">// get the registered parser instance</span>\n<span class="hljs-keyword">var</span> parser = context.GetService&lt;ICssSelectorParser&gt;();\n\n<span class="hljs-comment">// use as before</span>\n<span class="hljs-keyword">var</span> selector = parser.ParseSelector(<span class="hljs-string">&quot;foo&quot;</span>);\n</code></pre>\n<p>Normally, a <code>BrowsingContext</code> instance already exists thus making the access much simpler.</p>\n<h3 id="scripting">Scripting</h3>\n<p>:warn: Currently, <code>AngleSharp.Scripting.Js</code> is incompatible with AngleSharp v0.10.</p>\n<p>We plan to deprecate this package and release <code>AngleSharp.Js</code> instead. In the mean time there is no replacement.</p>\n<blockquote>\n<p>Recommendation: Stay at AngleSharp pre-v0.10 for the moment and wait until AngleSharp.Js is released. Sorry for inconvenience!</p>\n</blockquote>\n<h3 id="namespaces">Namespaces</h3>\n<p>The current version of AngleSharp reordered how namespaces are used. While previous versions used a model like <code>AngleSharp.Dom.Html</code>, the new release uses, e.g., <code>AngleSharp.Html.Dom</code>.</p>\n<p>The parsers have also moved. Formerly, you accessed the HTML parser via <code>AngleSharp.Parser.Html</code>. Now the access is done via <code>AngleSharp.Html.Parser</code>.</p>\n<p>The <code>AngleSharp.Network</code> namespace has been removed. All IO related definitions can be found in <code>AngleSharp.Io</code> (same name as the NuGet package). Network related definitions are contained within in <code>AngleSharp.Io.Network</code>.</p>\n<p>Furthermore, any core level text manipulation code can be found in <code>AngleSharp.Text</code>. Things that would be mainly seen as parts of a browser are now in <code>AngleSharp.Browser</code>.</p>\n<h3 id="extension-methods">Extension Methods</h3>\n<p>The common namespace <code>AngleSharp.Extensions</code> is gone. Now extension methods are always contained in their respective bucket. As an example the node extensions like <code>GetAncestors</code> are now in <code>AngleSharp.Dom</code> (as they are generic <code>INode</code> extensions and independent of <code>IHtmlElement</code>).</p>\n<p>Extension methods are now also considered important for script engines to bring extensibility to AngleSharp. Since C# does not allow us to create extension properties, e.g., <code>Style</code> of <code>IElement</code> is now available in form of an extension method contained in <code>AngleSharp.Css</code>. Indeed, two extension methods, <code>GetStyle</code> and <code>SetStyle</code> are defined. They are defined in a static class containing the <code>DomExposed</code> attribute for each DOM interface to extend. To define the methods as properties the <code>DomAccessor</code> attribute is used.</p>\n<p>Interesting for working with text sources (e.g., in parsers) is the <code>AngleSharp.Text</code> namespace. It carries also the extensions for, e.g., working with a <code>StringSource</code>, which is a source investigation object wrapped around an existing stream (as opposed to a <code>TextSource</code>, which wraps around a text document from a <code>Stream</code>).</p>\n<h3 id="missing%3F">Missing?</h3>\n<p>Don\'t hesitate to ask a question at <a href="https://stackoverflow.com/tags/anglesharp">StackOverflow</a> or here at GitHub. If something important is left unclear regarding the migration it should be included in this guide.</p>\n<p>You can also directly make a PR for this guide if you figured something out that should have been explained here. Thanks!</p>\n',r=function(){return e.createElement(o.ContentPage,null,e.createElement(o.PageContent,{meta:{title:"Migration Guide",section:"General"}},e.createElement(o.Markdown,{content:s,link:a,editLabel:"Edit on GitHub"})))};exports.default=r;
},{"react":"kvyv","../../scripts/components":"s4fr"}]},{},[], null)
//# sourceMappingURL=/tutorials-05-Migration.6adef0e8.js.map