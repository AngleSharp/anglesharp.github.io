{"version":3,"sources":["tools/__generated__/tutorials-03-Examples.tsx"],"names":[],"mappings":";AAmSC,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAlSD,IAAA,EAAA,EAAA,QAAA,UACA,EAAA,QAAA,4BAiSC,SAAA,EAAA,GAAA,GAAA,mBAAA,QAAA,OAAA,KAAA,IAAA,EAAA,IAAA,QAAA,EAAA,IAAA,QAAA,OAAA,EAAA,SAAA,GAAA,OAAA,EAAA,EAAA,IAAA,GAAA,SAAA,EAAA,EAAA,GAAA,IAAA,GAAA,GAAA,EAAA,WAAA,OAAA,EAAA,GAAA,OAAA,GAAA,iBAAA,GAAA,mBAAA,EAAA,MAAA,CAAA,QAAA,GAAA,IAAA,EAAA,EAAA,GAAA,GAAA,GAAA,EAAA,IAAA,GAAA,OAAA,EAAA,IAAA,GAAA,IAAA,EAAA,GAAA,EAAA,OAAA,gBAAA,OAAA,yBAAA,IAAA,IAAA,KAAA,EAAA,GAAA,YAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,GAAA,CAAA,IAAA,EAAA,EAAA,OAAA,yBAAA,EAAA,GAAA,KAAA,IAAA,EAAA,KAAA,EAAA,KAAA,OAAA,eAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,OAAA,EAAA,QAAA,EAAA,GAAA,EAAA,IAAA,EAAA,GAAA,EA7RK,IAAM,EAAO,6FACP,EAAO,02rBAoRJ,EAAA,WACb,OAAA,EAAA,cAAC,EAAD,YAAY,KAER,EAAA,cAAC,EAAD,YAAY,CAAC,KAAM,CAAS,MAAA,WAAqB,QAAA,YAC/C,EAAA,cAAC,EAAD,SAAS,CAAC,QAAS,EAAM,KAAM,EAAM,UAAW,sBAIvD,QAAA,QAAA","file":"tutorials-03-Examples.dc7843ef.js","sourceRoot":"..\\..\\node_modules\\piral-docs-tools\\src","sourcesContent":["// {\"title\":\"Examples\",\"section\":\"General\",\"link\":\"/docs/03-Examples\",\"source\":\"E:\\\\Code\\\\AngleSharp\\\\AngleSharp.Website\\\\docs\\\\tutorials\\\\03-Examples.md\"}\nimport * as React from 'react';\nimport { ContentPage } from '../../scripts/components';\n\n      import { PageContent, Markdown } from '../../scripts/components';\n\n      const link = \"https://github.com/AngleSharp/anglesharp.github.io/tree/main/docs/tutorials/03-Examples.md\";\n      const html = `\n<h1 id=\"example-code-snippets\">Example Code Snippets</h1>\n<p>This is a (growing) list of examples for every-day usage of AngleSharp.</p>\n<h2 id=\"parsing-a-well-defined-document\">Parsing a Well-Defined Document</h2>\n<p>Of course AngleSharp can handle well-defined documents very well. But what about a document that seems ill-defined, however, is in fact well-defined. The following document works, has no errors at all and is also used in production by Google. The serialized output of the document generation can be compared with the serialization done by browsers such as IE, Chrome or Firefox.</p>\n<pre><code class=\"hljs language-cs\"><span class=\"hljs-keyword\">var</span> source = <span class=\"hljs-string\">@&quot;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=en&gt;\n  &lt;meta charset=utf-8&gt;\n  &lt;meta name=viewport content=&quot;&quot;initial-scale=1, minimum-scale=1, width=device-width&quot;&quot;&gt;\n  &lt;title&gt;Error 404 (Not Found)!!1&lt;/title&gt;\n  &lt;style&gt;\n    *{margin:0;padding:0}html,code{font:15px/22px arial,sans-serif}html{background:#fff;color:#222;padding:15px}body{margin:7% auto 0;max-width:390px;min-height:180px;padding:30px 0 15px}* &gt; body{background:url(//www.google.com/images/errors/robot.png) 100% 5px no-repeat;padding-right:205px}p{margin:11px 0 22px;overflow:hidden}ins{color:#777;text-decoration:none}a img{border:0}@media screen and (max-width:772px){body{background:none;margin-top:0;max-width:none;padding-right:0}}#logo{background:url(//www.google.com/images/errors/logo_sm_2.png) no-repeat}@media only screen and (min-resolution:192dpi){#logo{background:url(//www.google.com/images/errors/logo_sm_2_hr.png) no-repeat 0% 0%/100% 100%;-moz-border-image:url(//www.google.com/images/errors/logo_sm_2_hr.png) 0}}@media only screen and (-webkit-min-device-pixel-ratio:2){#logo{background:url(//www.google.com/images/errors/logo_sm_2_hr.png) no-repeat;-webkit-background-size:100% 100%}}#logo{display:inline-block;height:55px;width:150px}\n  &lt;/style&gt;\n  &lt;a href=//www.google.com/&gt;&lt;span id=logo aria-label=Google&gt;&lt;/span&gt;&lt;/a&gt;\n  &lt;p&gt;&lt;b&gt;404.&lt;/b&gt; &lt;ins&gt;That’s an error.&lt;/ins&gt;\n  &lt;p&gt;The requested URL &lt;code&gt;/error&lt;/code&gt; was not found on this server.  &lt;ins&gt;That’s all we know.&lt;/ins&gt;&quot;</span>;\n\n<span class=\"hljs-comment\">//Use the default configuration for AngleSharp</span>\n<span class=\"hljs-keyword\">var</span> config = Configuration.Default;\n\n<span class=\"hljs-comment\">//Create a new context for evaluating webpages with the given config</span>\n<span class=\"hljs-keyword\">var</span> context = BrowsingContext.New(config);\n\n<span class=\"hljs-comment\">//Just get the DOM representation</span>\n<span class=\"hljs-keyword\">var</span> document = <span class=\"hljs-keyword\">await</span> context.OpenAsync(req =&gt; req.Content(source));\n\n<span class=\"hljs-comment\">//Serialize it back to the console</span>\nConsole.WriteLine(document.DocumentElement.OuterHtml);\n</code></pre>\n<p>So we define some source code, call the <code>OpenAsync</code> method of a an <code>BrowsingContext</code> instance. The <code>OpenAsync</code> method allows us to parse documents from any kind of requests, e.g., from a webserver. The callback style is called a &quot;virtual request&quot;, which does not invoke a real request, but stays within our code.</p>\n<p>In this case we use the provided source code to determine the content of the request's response. This content of the response is then parsed into an HTML document. Afterwards we serialize the DOM back to a string. Finally we output this string in the console.</p>\n<h2 id=\"simple-document-manipulation\">Simple Document Manipulation</h2>\n<p>AngleSharp constructs a DOM according to the official HTML5 specification. This also means that the resulting model is fully interactive and could be used for simple manipulation. The following example creates a document and changes the tree structure by inserting another paragraph element with some text.</p>\n<pre><code class=\"hljs language-cs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">async</span> Task <span class=\"hljs-title\">FirstExample</span>(<span class=\"hljs-params\"></span>)</span>\n{\n    <span class=\"hljs-comment\">//Use the default configuration for AngleSharp</span>\n    <span class=\"hljs-keyword\">var</span> config = Configuration.Default;\n\n    <span class=\"hljs-comment\">//Create a new context for evaluating webpages with the given config</span>\n    <span class=\"hljs-keyword\">var</span> context = BrowsingContext.New(config);\n\n    <span class=\"hljs-comment\">//Parse the document from the content of a response to a virtual request</span>\n    <span class=\"hljs-keyword\">var</span> document = <span class=\"hljs-keyword\">await</span> context.OpenAsync(req =&gt; req.Content(<span class=\"hljs-string\">&quot;&lt;h1&gt;Some example source&lt;/h1&gt;&lt;p&gt;This is a paragraph element&quot;</span>));\n\n    <span class=\"hljs-comment\">//Do something with document like the following</span>\n    Console.WriteLine(<span class=\"hljs-string\">&quot;Serializing the (original) document:&quot;</span>);\n    Console.WriteLine(document.DocumentElement.OuterHtml);\n\n    <span class=\"hljs-keyword\">var</span> p = document.CreateElement(<span class=\"hljs-string\">&quot;p&quot;</span>);\n    p.TextContent = <span class=\"hljs-string\">&quot;This is another paragraph.&quot;</span>;\n\n    Console.WriteLine(<span class=\"hljs-string\">&quot;Inserting another element in the body ...&quot;</span>);\n    document.Body.AppendChild(p);\n\n    Console.WriteLine(<span class=\"hljs-string\">&quot;Serializing the document again:&quot;</span>);\n    Console.WriteLine(document.DocumentElement.OuterHtml);\n}\n</code></pre>\n<p>Here the parser will create a new <code>IHtmlDocument</code> instance, which is then queried to find some matching nodes. In the example code above we also create another <code>IElement</code>, which is the <code>IHtmlParagraphElement</code>. This one is then appended to the <code>Body</code> node of the document.</p>\n<h2 id=\"getting-certain-elements\">Getting Certain Elements</h2>\n<p>AngleSharp exposes all DOM lists as <code>IEnumerable&lt;T&gt;</code> like <code>IEnumerable&lt;Node&gt;</code> for the <code>NodeList</code> class. This allows us to use LINQ in combination with some already given DOM capabilities like the <code>QuerySelectorAll</code> method.</p>\n<pre><code class=\"hljs language-cs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">async</span> Task <span class=\"hljs-title\">UsingLinq</span>(<span class=\"hljs-params\"></span>)</span>\n{\n    <span class=\"hljs-comment\">//Create a new context for evaluating webpages with the default config</span>\n    <span class=\"hljs-keyword\">var</span> context = BrowsingContext.New(Configuration.Default);\n\n    <span class=\"hljs-comment\">//Create a document from a virtual request / response pattern</span>\n    <span class=\"hljs-keyword\">var</span> document = <span class=\"hljs-keyword\">await</span> context.OpenAsync(req =&gt; req.Content(<span class=\"hljs-string\">&quot;&lt;ul&gt;&lt;li&gt;First item&lt;li&gt;Second item&lt;li class=&#x27;blue&#x27;&gt;Third item!&lt;li class=&#x27;blue red&#x27;&gt;Last item!&lt;/ul&gt;&quot;</span>));\n\n    <span class=\"hljs-comment\">//Do something with LINQ</span>\n    <span class=\"hljs-keyword\">var</span> blueListItemsLinq = document.All.Where(m =&gt; m.LocalName == <span class=\"hljs-string\">&quot;li&quot;</span> &amp;&amp; m.ClassList.Contains(<span class=\"hljs-string\">&quot;blue&quot;</span>));\n\n    <span class=\"hljs-comment\">//Or directly with CSS selectors</span>\n    <span class=\"hljs-keyword\">var</span> blueListItemsCssSelector = document.QuerySelectorAll(<span class=\"hljs-string\">&quot;li.blue&quot;</span>);\n\n    Console.WriteLine(<span class=\"hljs-string\">&quot;Comparing both ways ...&quot;</span>);\n\n    Console.WriteLine();\n    Console.WriteLine(<span class=\"hljs-string\">&quot;LINQ:&quot;</span>);\n\n    <span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-keyword\">var</span> item <span class=\"hljs-keyword\">in</span> blueListItemsLinq)\n    {\n        Console.WriteLine(item.Text());\n    }\n\n    Console.WriteLine();\n    Console.WriteLine(<span class=\"hljs-string\">&quot;CSS:&quot;</span>);\n\n    <span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-keyword\">var</span> item <span class=\"hljs-keyword\">in</span> blueListItemsCssSelector)\n    {\n        Console.WriteLine(item.Text());\n    }\n}\n</code></pre>\n<p>Since the <code>All</code> property of an <code>IDocument</code> returns all <code>IElement</code> nodes that are contained in a document, we can use it very efficiently with LINQ. On the other hand the <code>QuerySelectorAll</code> also returns (same as <code>All</code>) an <code>IHtmlCollection</code> object. Hence this can be filtered with LINQ as well! Additionally this list is already filtered.</p>\n<p>It is also possible to get the same as <code>All</code> with a selector - the special asterisk <code>*</code> selector:</p>\n<pre><code class=\"hljs language-cs\"><span class=\"hljs-comment\">//Same as document.All</span>\n<span class=\"hljs-keyword\">var</span> blueListItemsLinq = document.QuerySelectorAll(<span class=\"hljs-string\">&quot;*&quot;</span>).Where(m =&gt; m.LocalName == <span class=\"hljs-string\">&quot;li&quot;</span> &amp;&amp; m.ClassList.Contains(<span class=\"hljs-string\">&quot;blue&quot;</span>));\n</code></pre>\n<p>Is this exactly the same? Actually no - <code>All</code> returns a so called <em>live</em> DOM list, i.e. if we save the object somewhere we will always have access to the latest DOM changes.</p>\n<h2 id=\"getting-single-elements\">Getting Single Elements</h2>\n<p>Additionally we have the <code>QuerySelector</code> method. This one is quite close to LINQ statements that use <code>FirstOrDefault()</code> for generating results. The tree traversal might be a little bit more efficient using the <code>QuerySelector</code> method.</p>\n<p>Let's see some sample code:</p>\n<pre><code class=\"hljs language-cs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">async</span> Task <span class=\"hljs-title\">SingleElements</span>(<span class=\"hljs-params\"></span>)</span>\n{\n    <span class=\"hljs-comment\">//Create a new context for evaluating webpages with the default config</span>\n    <span class=\"hljs-keyword\">var</span> context = BrowsingContext.New(Configuration.Default);\n\n    <span class=\"hljs-comment\">//Create a new document</span>\n    <span class=\"hljs-keyword\">var</span> document = <span class=\"hljs-keyword\">await</span> context.OpenAsync(req =&gt; req.Content(<span class=\"hljs-string\">&quot;&lt;b&gt;&lt;i&gt;This is some &lt;em&gt; bold &lt;u&gt;and&lt;/u&gt; italic &lt;/em&gt; text!&lt;/i&gt;&lt;/b&gt;&quot;</span>));\n\n    <span class=\"hljs-keyword\">var</span> emphasize = document.QuerySelector(<span class=\"hljs-string\">&quot;em&quot;</span>);\n\n    Console.WriteLine(<span class=\"hljs-string\">&quot;Difference between several ways of getting text:&quot;</span>);\n    Console.WriteLine();\n    Console.WriteLine(<span class=\"hljs-string\">&quot;Only from C# / AngleSharp:&quot;</span>);\n    Console.WriteLine();\n    Console.WriteLine(emphasize.ToHtml());   <span class=\"hljs-comment\">//&lt;em&gt; bold &lt;u&gt;and&lt;/u&gt; italic &lt;/em&gt;</span>\n    Console.WriteLine(emphasize.Text());   <span class=\"hljs-comment\">// bold and italic</span>\n\n    Console.WriteLine();\n    Console.WriteLine(<span class=\"hljs-string\">&quot;From the DOM:&quot;</span>);\n    Console.WriteLine();\n    Console.WriteLine(emphasize.InnerHtml);  <span class=\"hljs-comment\">// bold &lt;u&gt;and&lt;/u&gt; italic</span>\n    Console.WriteLine(emphasize.OuterHtml);  <span class=\"hljs-comment\">//&lt;em&gt; bold &lt;u&gt;and&lt;/u&gt; italic &lt;/em&gt;</span>\n    Console.WriteLine(emphasize.TextContent);<span class=\"hljs-comment\">// bold and italic</span>\n}\n</code></pre>\n<p>The output commands try to demonstrate the differences between several ways of getting back strings from nodes. In fact the DOM property <code>OuterHtml</code> uses the <code>ToHtml()</code> version to generate the HTML code. The other variants are all different. While <code>Text()</code> is just a helper to strip text (and omit unwanted text contents like in <code>&lt;script&gt;</code> tags), the other two variants behave like the official W3C specified properties, leaving everything as it is.</p>\n<p>Extension methods such as <code>ToHtml()</code> and <code>Text()</code> can be found in the namespace <code>AngleSharp.Extensions</code>.</p>\n<h2 id=\"connecting-javascript-evaluation\">Connecting JavaScript Evaluation</h2>\n<p>The project also contains a sample JavaScript engine based on Jint (JavaScript Interpreter).</p>\n<p>The sample starts by creating a customized version based on the pre-defined <code>Configuration</code> class. Here we just include another engine, located in <code>AngleSharp.Js</code> (namespace and project). It is important to also enable scripting. AngleSharp knows that having script engines and using them are two different things.</p>\n<pre><code class=\"hljs language-ps1\"><span class=\"hljs-built_in\">Install-Package</span> AngleSharp.Js\n</code></pre>\n<p>Here is the full sample code.</p>\n<pre><code class=\"hljs language-cs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">async</span> Task <span class=\"hljs-title\">SimpleScriptingSample</span>(<span class=\"hljs-params\"></span>)</span>\n{\n    <span class=\"hljs-comment\">//We require a custom configuration</span>\n    <span class=\"hljs-keyword\">var</span> config = Configuration.Default.WithJs();\n\n    <span class=\"hljs-comment\">//Create a new context for evaluating webpages with the given config</span>\n    <span class=\"hljs-keyword\">var</span> context = BrowsingContext.New(config);\n\n    <span class=\"hljs-comment\">//This is our sample source, we will set the title and write on the document</span>\n    <span class=\"hljs-keyword\">var</span> source = <span class=\"hljs-string\">@&quot;&lt;!doctype html&gt;\n        &lt;html&gt;\n        &lt;head&gt;&lt;title&gt;Sample&lt;/title&gt;&lt;/head&gt;\n        &lt;body&gt;\n        &lt;script&gt;\n        document.title = &#x27;Simple manipulation...&#x27;;\n        document.write(&#x27;&lt;span class=greeting&gt;Hello World!&lt;/span&gt;&#x27;);\n        &lt;/script&gt;\n        &lt;/body&gt;&quot;</span>;\n\n    <span class=\"hljs-keyword\">var</span> document = <span class=\"hljs-keyword\">await</span> context.OpenAsync(req =&gt; req.Content(source));\n\n    <span class=\"hljs-comment\">//Modified HTML will be output</span>\n    Console.WriteLine(document.DocumentElement.OuterHtml);\n}\n</code></pre>\n<p>This code just parses the given HTML code, encounters the provided JavaScript and executes it. The JavaScript will manipulate the document at the given point, changing the title of the document and appending some more HTML to parse. In the end we will see, that the printed (serialized) HTML is different to the original one.</p>\n<h2 id=\"more-complex-javascript-dom-interaction\">More Complex JavaScript DOM Interaction</h2>\n<p>Using JavaScript with AngleSharp is no problem. In the current state we can also easily use DOM manipulation like creating elements, appending or removing them.</p>\n<p>For this example, we'll need two additional packages besides <code>AngleSharp</code>: <code>AngleSharp.Js</code> (for evaluating JavaScript) and <code>AngleSharp.Css</code> (for understanding CSS).</p>\n<pre><code class=\"hljs language-ps1\"><span class=\"hljs-built_in\">Install-Package</span> AngleSharp.Js\n<span class=\"hljs-built_in\">Install-Package</span> AngleSharp.Css\n</code></pre>\n<p>The following example code performs DOM queries, creates new elements and removes existing ones.</p>\n<pre><code class=\"hljs language-cs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ExtendedScriptingSample</span>(<span class=\"hljs-params\"></span>)</span>\n{\n    <span class=\"hljs-comment\">//We require a custom configuration with JavaScript and CSS</span>\n    <span class=\"hljs-keyword\">var</span> config = Configuration.Default.WithJs().WithCss();\n\n    <span class=\"hljs-comment\">//Create a new context for evaluating webpages with the given config</span>\n    <span class=\"hljs-keyword\">var</span> context = BrowsingContext.New(config);\n\n    <span class=\"hljs-comment\">//This is our sample source, we will do some DOM manipulation</span>\n    <span class=\"hljs-keyword\">var</span> source = <span class=\"hljs-string\">@&quot;&lt;!doctype html&gt;\n        &lt;html&gt;\n        &lt;head&gt;&lt;title&gt;Sample&lt;/title&gt;&lt;/head&gt;\n        &lt;style&gt;\n            .bold {\n                font-weight: bold;\n            }\n            .italic {\n                font-style: italic;\n            }\n            span {\n                font-size: 12pt;\n            }\n            div {\n                background: #777;\n                color: #f3f3f3;\n            }\n        &lt;/style&gt;\n        &lt;body&gt;\n        &lt;div id=content&gt;&lt;/div&gt;\n        &lt;script&gt;\n        (function() {\n            var doc = document;\n            var content = doc.querySelector(&#x27;#content&#x27;);\n            var span = doc.createElement(&#x27;span&#x27;);\n            span.id = &#x27;myspan&#x27;;\n            span.classList.add(&#x27;bold&#x27;, &#x27;italic&#x27;);\n            span.textContent = &#x27;Some sample text&#x27;;\n            content.appendChild(span);\n            var script = doc.querySelector(&#x27;script&#x27;);\n            script.parentNode.removeChild(script);\n        })();\n        &lt;/script&gt;\n        &lt;/body&gt;&quot;</span>;\n\n    <span class=\"hljs-keyword\">var</span> document = <span class=\"hljs-keyword\">await</span> context.OpenAsync(req =&gt; req.Content(source));\n\n    <span class=\"hljs-comment\">//HTML will have changed completely (e.g., no more script element)</span>\n    Console.WriteLine(document.DocumentElement.OuterHtml);\n}\n</code></pre>\n<p>In principle other JavaScript engines can be added as well. Of course manually wrapping the objects would give a superior performance compared to the automatic version that is based on reflection. Nevertheless, the <code>AngleSharp.Js</code> library (available on NuGet) shows the possibilities and the basics of binding an existing JavaScript engine to AngleSharp.</p>\n<h2 id=\"events-in-javascript-and-c%23\">Events in JavaScript and C#</h2>\n<p>The beginning of the following example is exactly the same as the previous two examples. We create a custom configuration, which contains the <code>JavaScriptEngine</code> engine. After enabling scripting (and styling in this case), we can parse our document.</p>\n<p>The sample document of this example consists of a single script, that calls the <code>console.log</code> method. One time before adding a listener, another time after adding the listener.</p>\n<p>You'll need to add the additional <code>AngleSharp.Js</code> package:</p>\n<pre><code class=\"hljs language-ps1\"><span class=\"hljs-built_in\">Install-Package</span> AngleSharp.Js\n</code></pre>\n<p>The listener is called once the document is fully loaded. This happens after executing the provided JavaScript, hence we should see this event at the end. We also registered another event listener, which will be invoked once the custom event <strong>hello</strong> is dispatched.</p>\n<pre><code class=\"hljs language-cs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">EventScriptingExample</span>(<span class=\"hljs-params\"></span>)</span>\n{\n    <span class=\"hljs-comment\">//We require a custom configuration</span>\n    <span class=\"hljs-keyword\">var</span> config = Configuration.Default.WithJs();\n\n    <span class=\"hljs-comment\">//Create a new context for evaluating webpages with the given config</span>\n    <span class=\"hljs-keyword\">var</span> context = BrowsingContext.New(config);\n\n    <span class=\"hljs-comment\">//This is our sample source, we will trigger the load event</span>\n    <span class=\"hljs-keyword\">var</span> source = <span class=\"hljs-string\">@&quot;&lt;!doctype html&gt;\n        &lt;html&gt;\n        &lt;head&gt;&lt;title&gt;Event sample&lt;/title&gt;&lt;/head&gt;\n        &lt;body&gt;\n        &lt;script&gt;\n        console.log(&#x27;Before setting the handler!&#x27;);\n\n        document.addEventListener(&#x27;load&#x27;, function() {\n        console.log(&#x27;Document loaded!&#x27;);\n        });\n\n        document.addEventListener(&#x27;hello&#x27;, function() {\n        console.log(&#x27;hello world from JavaScript!&#x27;);\n        });\n\n        console.log(&#x27;After setting the handler!&#x27;);\n        &lt;/script&gt;\n        &lt;/body&gt;&quot;</span>;\n\n    <span class=\"hljs-keyword\">var</span> document = <span class=\"hljs-keyword\">await</span> context.OpenAsync(req =&gt; req.Content(source));\n\n    <span class=\"hljs-comment\">//HTML should be output in the end</span>\n    Console.WriteLine(document.DocumentElement.OuterHtml);\n\n    <span class=\"hljs-comment\">//Register Hello event listener from C# (we also have one in JS)</span>\n    document.AddEventListener(<span class=\"hljs-string\">&quot;hello&quot;</span>, (s, ev) =&gt;\n    {\n        Console.WriteLine(<span class=\"hljs-string\">&quot;hello world from C#!&quot;</span>);\n    });\n\n    <span class=\"hljs-keyword\">var</span> e = document.CreateEvent(<span class=\"hljs-string\">&quot;event&quot;</span>);\n    e.Init(<span class=\"hljs-string\">&quot;hello&quot;</span>, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-literal\">false</span>);\n    document.Dispatch(e);\n}\n</code></pre>\n<p>We also register an event listener for this custom event in C#. Here we have intelli sense and all other comfortable tools. After initiating the event via the official API we will recognize output from both registered event listeners (coming from JavaScript and C#).</p>\n`;\n    \n\nexport default () => (\n  <ContentPage>\n    \n      <PageContent meta={{\"title\":\"Examples\",\"section\":\"General\"}}>\n        <Markdown content={html} link={link} editLabel={\"Edit on GitHub\"} />\n      </PageContent>\n    \n  </ContentPage>\n);"]}