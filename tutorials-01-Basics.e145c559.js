parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"sRUz":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var e=s(require("react")),n=require("../../scripts/components");function t(e){if("function"!=typeof WeakMap)return null;var n=new WeakMap,s=new WeakMap;return(t=function(e){return e?s:n})(e)}function s(e,n){if(!n&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var s=t(n);if(s&&s.has(e))return s.get(e);var a={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var r in e)if("default"!==r&&Object.prototype.hasOwnProperty.call(e,r)){var l=o?Object.getOwnPropertyDescriptor(e,r):null;l&&(l.get||l.set)?Object.defineProperty(a,r,l):a[r]=e[r]}return a.default=e,s&&s.set(e,a),a}var a="https://github.com/AngleSharp/anglesharp.github.io/tree/main/docs/tutorials/01-Basics.md",o='\n<h1 id="getting-started">Getting Started</h1>\n<h2 id="requirements">Requirements</h2>\n<p>AngleSharp comes currently in two flavors: on Windows for .NET 4.6 and in general targetting .NET Standard 2.0 platforms.</p>\n<p>Most of the features of the library do not require .NET 4.6, which means you could create your own fork and modify it to work with previous versions of the .NET-Framework.</p>\n<h2 id="getting-anglesharp-over-nuget">Getting AngleSharp over NuGet</h2>\n<p>The simplest way of integrating AngleSharp to your project is by using NuGet. You can install AngleSharp by opening the package manager console (PM) and typing in the following statement:</p>\n<pre><code class="hljs language-ps1"><span class="hljs-built_in">Install-Package</span> AngleSharp\n</code></pre>\n<p>You can also use the graphical library package manager (&quot;Manage NuGet Packages for Solution&quot;). Searching for &quot;AngleSharp&quot; in the official NuGet online feed will find this library.</p>\n<h2 id="first-steps">First Steps</h2>\n<p>In the most simple case you have already a document source and want it to be parsed. This could look like the following:</p>\n<pre><code class="hljs language-c#"><span class="hljs-keyword">using</span> System;\n<span class="hljs-keyword">using</span> AngleSharp;\n<span class="hljs-keyword">using</span> AngleSharp.Html.Parser;\n\n<span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> {\n    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span> {\n        <span class="hljs-comment">//Use the default configuration for AngleSharp</span>\n        <span class="hljs-keyword">var</span> config = Configuration.Default;\n\n        <span class="hljs-comment">//Create a new context for evaluating webpages with the given config</span>\n        <span class="hljs-keyword">var</span> context = BrowsingContext.New(config);\n\n        <span class="hljs-comment">//Source to be parsed</span>\n        <span class="hljs-keyword">var</span> source = <span class="hljs-string">&quot;&lt;h1&gt;Some example source&lt;/h1&gt;&lt;p&gt;This is a paragraph element&quot;</span>;\n\n        <span class="hljs-comment">//Create a virtual request to specify the document to load (here from our fixed string)</span>\n        <span class="hljs-keyword">var</span> document = <span class="hljs-keyword">await</span> context.OpenAsync(req =&gt; req.Content(source));\n\n        <span class="hljs-comment">//Do something with document like the following</span>\n        Console.WriteLine(<span class="hljs-string">&quot;Serializing the (original) document:&quot;</span>);\n        Console.WriteLine(document.DocumentElement.OuterHtml);\n\n        <span class="hljs-keyword">var</span> p = document.CreateElement(<span class="hljs-string">&quot;p&quot;</span>);\n        p.TextContent = <span class="hljs-string">&quot;This is another paragraph.&quot;</span>;\n\n        Console.WriteLine(<span class="hljs-string">&quot;Inserting another element in the body ...&quot;</span>);\n        document.Body.AppendChild(p);\n\n        Console.WriteLine(<span class="hljs-string">&quot;Serializing the document again:&quot;</span>);\n        Console.WriteLine(document.DocumentElement.OuterHtml);\n    }\n}\n</code></pre>\n<p>Of course one could go further and perform a lot more DOM manipulations.</p>\n<p><code>IBrowsingContext</code> represents a browsing context where document evaluations take place. This is a required construct for parsing any HTML page. It also allows submitting forms, following links, downloading resources, and more. We can think of it like a tab in a standard browser.</p>\n<p>Alternatively, we could have used the following code in the beginning:</p>\n<pre><code class="hljs language-c#"><span class="hljs-keyword">var</span> context = BrowsingContext.New(config);\n<span class="hljs-keyword">var</span> parser = context.GetService&lt;IHtmlParser&gt;();\n<span class="hljs-keyword">var</span> source = <span class="hljs-string">&quot;&lt;h1&gt;Some example source&lt;/h1&gt;&lt;p&gt;This is a paragraph element&quot;</span>;\n<span class="hljs-keyword">var</span> document = parser.ParseDocument(source);\n</code></pre>\n<p>So what is the <code>IHtmlParser</code>? This is a class that represents the HTML5 parser front-end. It has methods to create an instance of <code>IHtmlDocument</code>, which carries the parsed DOM. Since HTML is quite relaxed about possible errors, there is nothing like exceptions. We only might get some error messages. These messages can be received via a special interface and should be treated like warnings.</p>\n<h2 id="the-dom">The DOM</h2>\n<p>The idea behind AngleSharp is to provide state-of-the-art parsers (for CSS, HTML and related objects, such as URLs), which generate the same DOM as a modern browser would do. The same DOM means that the same API is used as known from JavaScript / from current browsers. This API is standardized and well-known among web developers. Also the liveliness of DOM interaction is then not only restricted to JavaScript, or browser hosting scenarios. AngleSharp will make it possible to basically bring the core of a modern browser to your code.</p>\n<p>The whole DOM has been transported to a logical class structure. A part of this structure could be resolved as the following picture shows. Note that the picture shows an older DOM model. The current version of AngleSharp implements the latest DOM model, which is slightly different. Nevertheless, the picture is still useful to get the right idea.</p>\n<p><img src="http://www.codeproject.com/KB/library/609053/dom.png" alt="The DOM as class relations"></p>\n<p>There are some restrictions to the DOM:</p>\n<ul>\n<li>One cannot just create elements in general - there are nearly always factories in the <code>IDocument</code> instance or specialization such as the <code>IHtmlDocument</code></li>\n<li>Inheritance of known elements is not possible</li>\n<li>Modifications of the DOM have to follow the given paths</li>\n</ul>\n<p>This means that one <strong>cannot</strong> write code like (note: the <code>HtmlParagraphElement</code> element is internal, anyway - it is the (default) implementation of the <code>IHtmlParagraphElement</code> interface),</p>\n<pre><code class="hljs language-c#"><span class="hljs-keyword">var</span> paragraph = <span class="hljs-keyword">new</span> HTMLParagraphElement();\n</code></pre>\n<p>as this is also not possible in, e.g., JavaScript. What one requires is an instance of the <code>IDocument</code> interface.</p>\n<p>If we assume that this instance is called <code>document</code> we <strong>can</strong> now write</p>\n<pre><code class="hljs language-c#"><span class="hljs-keyword">var</span> paragraph = document.CreateElement(<span class="hljs-string">&quot;p&quot;</span>);\n</code></pre>\n<p>which creates the paragraph (&lt;p&gt;) element and assigns the given document as the owner of the node. As in the JavaScript / DOM world, we did not append the paragraph anywhere in the document. When an element is not being appended it has no parent and thus does not appear in the DOM tree. As a consequence it would not be serialized again, and some special actions would be without meaning. Furthermore, queries on the DOM tree would not show the given elements.</p>\n<p>On the other side those restrictions result in all constructors being marked as <code>internal</code>. This prevents inheritance (even though the class might be not <code>sealed</code>) and requires users to follow the given paths.</p>\n<p>The advantage of scripting languages such as JavaScript is that even though <code>CreateElement</code> only returns an <code>IElement</code>, one is able to access even specialized properties and methods of, e.g., <code>IHtmlElement</code>, if available. In static typed languages (such as C#) we require casts. One way out would be to use <code>dynamic</code>, or handy extension methods such as</p>\n<pre><code class="hljs language-c#"><span class="hljs-keyword">var</span> paragraph = document.CreateElement&lt;IHtmlParagraphElement&gt;();\n</code></pre>\n<p>This works and directly returns an object of type <code>IHtmlParagraphElement</code>. No cast needed and one (dubious) string allocation saved. This particular extension method is placed in the namespace <code>AngleSharp.Dom</code>.</p>\n<h2 id="beyond-the-dom">Beyond the DOM</h2>\n<p>AngleSharp provides several properties and methods that are not accessible via the standardized DOM properties and methods. To distinguish between standardized and extended a simple attribute class called <code>DomNameAttribute</code> has been added. The attribute is applied in those cases, where the decorated class / event / method or property is also specified in the official W3C standard. Additionally the official name is set, since AngleSharp follows the PascalCase convention, while the DOM follows the camelCase convention.</p>\n<p>AngleSharp also provides objects that are not listed at all in the official W3C specification. Sometimes those classes are specializations of W3C defined objects (e.g. <code>MathElement</code> is derived from <code>Element</code>, however, while <code>Element</code> is also specified in the official specification, <code>MathElement</code> is not), or just part of the AngleSharp eco-system.</p>\n<p>The interface <code>IConfiguration</code> can be used to configure the behavior of AngleSharp. It is possible to derive from a sample implementation called <code>Configuration</code>, to use the sample implementation directly (e.g. <code>new Configuration()</code>) or to start by implementing our own configuration via <code>IConfiguration</code>.</p>\n<p>If no configuration is provided, AngleSharp will use a default configuration. The default configuration can also be set, removing any configuration transportation requirements at all. In most scenarios using <code>Configuration.Default</code> makes sense. Note that the <code>Configuration</code> is immutable and that all extension methods for <code>IConfiguration</code> will never try to modify the passed object. They will always return an unmodified object, or a new object with the modifications.</p>\n<p>Finally AngleSharp also brings some very helpful extension methods that try to be similar for what jQuery offers in JavaScript. Using the namespace <code>AngleSharp</code> one can access methods like <code>Html</code>, <code>Css</code>, <code>Attr</code> or <code>Text</code>. These methods operate on a given <code>IEnumerable&lt;IElement&gt;</code> like an existing <code>IHtmlCollection</code>. The purpose is quite simple: To easily modify the given DOM.</p>\n<pre><code class="hljs language-c#"><span class="hljs-comment">// using AngleSharp.Html.Parser;</span>\n<span class="hljs-comment">// using AngleSharp.Dom;</span>\n<span class="hljs-comment">// using AngleSharp;</span>\n\n<span class="hljs-comment">//Create a new browsing context for hosting the document</span>\n<span class="hljs-keyword">var</span> context = Browsing.New(Configuration.Default);\n<span class="hljs-comment">//Generate HTML DOM for the following source code</span>\n<span class="hljs-keyword">var</span> document = <span class="hljs-keyword">await</span> context.OpenAsync(req =&gt; req.Content(<span class="hljs-string">&quot;&lt;ul&gt;&lt;li&gt;First element&lt;li&gt;Second element&lt;li&gt;third&lt;li class=bla&gt;Last&quot;</span>));\n<span class="hljs-comment">//Get all li elements and set the test attribute to the value test; elements still contains all li elements</span>\n<span class="hljs-keyword">var</span> elements = document.QuerySelectorAll(<span class="hljs-string">&quot;li&quot;</span>).Attr(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>);\n</code></pre>\n<p>It should be noted that applying <code>Text</code> or <code>Html</code> will have consequences for the DOM. For example if we apply it to a list of several elements, where some elements of the list contain other elements of the same list, the resulting list will still contain all those elements, however, the document will not.</p>\n<p>The reason for this behavior is quite simple: Applying e.g. <code>Html</code> will remove all children of a node and append new children, which have been obtained by parsing the given source. Similarly <code>Text</code> will remove all children and append an <code>IText</code> node with the given textual content.</p>\n',r=function(){return e.createElement(n.ContentPage,null,e.createElement(n.PageContent,{meta:{title:"Getting Started",section:"General"}},e.createElement(n.Markdown,{content:o,link:a,editLabel:"Edit on GitHub"})))};exports.default=r;
},{"react":"kvyv","../../scripts/components":"s4fr"}]},{},[], null)
//# sourceMappingURL=/tutorials-01-Basics.e145c559.js.map