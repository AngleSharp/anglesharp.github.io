parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"Ch8f":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var s=a(require("react")),e=require("../../scripts/components");function n(s){if("function"!=typeof WeakMap)return null;var e=new WeakMap,a=new WeakMap;return(n=function(s){return s?a:e})(s)}function a(s,e){if(!e&&s&&s.__esModule)return s;if(null===s||"object"!=typeof s&&"function"!=typeof s)return{default:s};var a=n(e);if(a&&a.has(s))return a.get(s);var t={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var l in s)if("default"!==l&&Object.prototype.hasOwnProperty.call(s,l)){var r=o?Object.getOwnPropertyDescriptor(s,l):null;r&&(r.get||r.set)?Object.defineProperty(t,l,r):t[l]=s[l]}return t.default=s,a&&a.set(s,t),t}var t="https://github.com/AngleSharp/anglesharp.github.io/tree/main/docs/general/05-Questions.md",o='\n<h1 id="frequently-asked-questions">Frequently Asked Questions</h1>\n<h2 id="how-to-download-a-picture%3F">How to download a picture?</h2>\n<p>This is nothing directly to do with AngleSharp. You can perform any kind of requests to some URL.</p>\n<p>Here is an example:</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">var</span> imageUrl = <span class="hljs-string">@&quot;https://via.placeholder.com/150&quot;</span>;\n<span class="hljs-keyword">var</span> localPath = <span class="hljs-string">@&quot;g:downloadsimage.jpg&quot;</span>;\n\n<span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> HttpClient())\n{\n\t<span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> response = <span class="hljs-keyword">await</span> client.GetAsync(imageUrl))\n\t{\n\t\t<span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> source = <span class="hljs-keyword">await</span> response.Content.ReadAsStreamAsync())\n\t\t{\n\t\t\t<span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> target = File.OpenWrite(localPath))\n\t\t\t{\n\t\t\t\t<span class="hljs-keyword">await</span> source.CopyToAsync(target);\n\t\t\t}\n\t\t}\n\t}\n}\n</code></pre>\n<p>If there is some reason for needing to, e.g., re-use some cookies obtained via AngleSharp then you can either share the cookie container or use the requester from AngleSharp.</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">var</span> imageUrl = <span class="hljs-string">@&quot;https://via.placeholder.com/150&quot;</span>;\n<span class="hljs-keyword">var</span> localPath = <span class="hljs-string">@&quot;g:downloadsimage.jpg&quot;</span>;\n<span class="hljs-keyword">var</span> download = context.GetService&lt;IDocumentLoader&gt;().FetchAsync(<span class="hljs-keyword">new</span> DocumentRequest(<span class="hljs-keyword">new</span> Url(imageUrl)));\n\n<span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> response = <span class="hljs-keyword">await</span> download.Task)\n{\n\t<span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> target = File.OpenWrite(localPath))\n\t{\n\t\t<span class="hljs-keyword">await</span> response.Content.CopyToAsync(target);\n\t}\n}\n</code></pre>\n<p>This assumes a configuration / context such as</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">var</span> config = Configuration.Default.WithDefaultLoader(<span class="hljs-keyword">new</span> LoaderOptions { IsResourceLoadingEnabled = <span class="hljs-literal">true</span> }).WithCookies();\n<span class="hljs-keyword">var</span> context = BrowsingContext.New(config);\n</code></pre>\n<h2 id="is-it-possible-to-get-the-html-after-javascript-and-blazor-run%3F">Is it possible to get the HTML after JavaScript and Blazor run?</h2>\n<p>AngleSharp is just a browser core and even though running JavaScript is possible (there is an experimental plugin out there), it will not work with complicated stuff (e.g., running Angular). I do not know if any WASM plugin exists, so I guess running something like Blazor is not possible unless someone codes the WASM plugin.</p>\n<h2 id="how-to-convert-html-to-xml-using-anglesharp%3F">How to convert HTML to XML using AngleSharp?</h2>\n<p>Unfortunately there is no (always working, i.e., silver bullet) way to convert HTML to XML â€“ both formats are actually incompatible. The problem gets even more severe with incompatible object models, e.g., creating a DOM from AngleSharp and converting it to an <code>XmlDocument</code> instance.</p>\n<p>You would need to perform the conversion &quot;manually&quot; with a mapping function. As the formats are incompatible you will need to specify what to convert and how to react in the cases where no mapping exists...</p>\n<h2 id="how-to-deal-with-other-methods-of-authentication-(e.g.%2C-kerberos)%3F">How to deal with other methods of authentication (e.g., Kerberos)?</h2>\n<p>This is highly dependent on the authentication scheme. Let\'s say we use Windows authentication scheme (&quot;IWA&quot; or sometimes referred to as NTLM/Kerberos). There are several ways of archiving this (you will definitely need the <code>CookieContainer</code> to be active, so <code>WithCookies()</code> is required, however, will not get you authenticated in the first place). You will definitely want to either use the <code>HttpRequester</code> from the <em>AngleSharp.Io</em> library (as this one offers you the ability to re-configure it) or roll out your own implementation of an IRequester.</p>\n<p>For the old <code>HttpWebRequest</code> you just set the right authentication level and credentials (e.g., as below) to get the proper authentication going.</p>\n<pre><code class="hljs language-cs">req.AuthenticationLevel = System.Net.Security.AuthenticationLevel.MutualAuthRequested;\nreq.Credentials = System.Net.CredentialCache.DefaultNetworkCredentials;\n</code></pre>\n<p>Another very common scenario is standard network credentials. These can also be easier supplied using the <code>HttpClient</code>-based approach of <em>AngleSharp.Io</em>.</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">var</span> credentials = <span class="hljs-keyword">new</span> NetworkCredential(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;pass&quot;</span>, <span class="hljs-string">&quot;domain&quot;</span>);\n<span class="hljs-keyword">var</span> handler = <span class="hljs-keyword">new</span> HttpClientHandler { Credentials = credentials };\n<span class="hljs-keyword">var</span> config = Configuration.Default\n    .WithRequesters(handler)\n    .WithCookies()\n    .WithDefaultLoader();\n<span class="hljs-keyword">var</span> context = BrowsingContext.New(config);\n<span class="hljs-keyword">var</span> document = <span class="hljs-keyword">await</span> context.OpenAsync(url);\n</code></pre>\n<h2 id="how-to-use-a-proxy-with-anglesharp%3F">How to use a proxy with AngleSharp?</h2>\n<p>We recommend using the <code>HttpClient</code>-based <code>IRequester</code> implementation from <em>AngleSharp.Io</em>. This one can be properly re-configured.</p>\n<p>As an example the following handler may be used coming from some <code>proxyServerSettings</code> providing some <code>Port</code> and <code>Address</code>.</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">var</span> handler = <span class="hljs-keyword">new</span> HttpClientHandler()\n{\n    Proxy = <span class="hljs-keyword">new</span> WebProxy(String.Format(<span class="hljs-string">&quot;{0}:{1}&quot;</span>, proxyServerSettings.Address, proxyServerSettings.Port), <span class="hljs-literal">false</span>),\n    PreAuthenticate = <span class="hljs-literal">true</span>,\n    UseDefaultCredentials = <span class="hljs-literal">false</span>,\n};\n</code></pre>\n<h2 id="the-content-in-textareas-is-html-encoded!">The content in textareas is HTML encoded!</h2>\n<p>Given some content like</p>\n<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span>&gt;</span>one<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>two\n</code></pre>\n<p>AngleSharp views this parts like that:</p>\n<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span>&gt;</span>one<span class="hljs-symbol">&amp;lt;</span>p<span class="hljs-symbol">&amp;gt;</span>two<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n</code></pre>\n<p>This is standard behavior as defined in the official HTML specification. The textarea tag switches to a new parse state and does not automatically close. It needs to encounter a textarea closing tag for being closed. This new parsing state essentially ignores all reserved characters (e.g., <code>&lt;</code>), which leads to the serialization representation that you see using to their encoded values.</p>\n<p>So the problem is not the encoding (this is just a serialization representation), but rather, that the textarea did not close, which will now place all (assumed?) children in the textarea as raw input.</p>\n<p>There is, unfortunately, nothing that you can do here - you will need to close the <code>textarea</code>. All browsers (hence the initial remark with the specification) see it the same way - so this is not unique to AngleSharp.</p>\n<h2 id="what-can-i-%22click%22-in-anglesharp%3F">What can I &quot;click&quot; in AngleSharp?</h2>\n<p>The only thing you can click with AngleSharp (Core, i.e., non-JS) is everything that has an anchor (the link will be followed), such as <code>a</code>, or submit (e.g., <code>button</code>) buttons where the form will be submitted. If, e.g., we have a <code>div</code> that has a click handler defined in JS nothing would come out.</p>\n<h2 id="how-can-i-perform-a-click-on-a-div-without-an-ui%3F">How can I perform a click on a div without an UI?</h2>\n<p>Let\'s first visit again what can be done with AngleSharp:</p>\n<ul>\n<li>Any kind of requests incl. their manipulation (on request, but also before response)</li>\n<li>General cookie management (and their manipulation, of course)</li>\n<li>Querying the DOM and perform &quot;simple&quot; actions (e.g., clicking a button, submitting a form)</li>\n<li>Running trivial JavaScript files</li>\n</ul>\n<p>Here trivial means: Scripts that do not need any capabilities beyond what AngleSharp offers, e.g., rendering tree information, advanced CSSOM access, ... - or scripts that require non-ES5 compliant parsers (e.g., make use of ES6 or some special non-standard capabilities).</p>\n<p>The problem is that in order to &quot;click&quot; a div on a page a script needs to be run. This script can now fall into the &quot;trivial&quot; category, however, most likely it is not. Now you have 2 options:</p>\n<ul>\n<li>Try it out and maybe it works / great, otherwise ...</li>\n<li>See what the script is doing (obviously some HTTP request eventually ...) and do the same</li>\n</ul>\n<p>The latter can of course be re-implemented in C# / AngleSharp. So you can create an HTTP request, get the data and either do something on that data set directly (it may be JSON and already what you want ....) or (if it is serving partial HTML) re-parse it and integrate it on the real page.</p>\n<h2 id="how-can-i-remove-all-elements-matching-a-certain-selector%3F">How can I remove all elements matching a certain selector?</h2>\n<p>The following code works for all <code>span</code> elements. Make sure to adjust the selector according to your problem.</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> document.QuerySelectorAll(<span class="hljs-string">&#x27;span&#x27;</span>))\n{\n    element.Remove();\n}\n</code></pre>\n<h2 id="how-is-documenturi-different-from-url%3F">How is DocumentUri different from Url?</h2>\n<p>The properties correspond to DOM properties of the same names.</p>\n<p>Per MDN:</p>\n<blockquote>\n<p>HTML documents have a document.URL property which returns the same value [as document.documentURI]. Unlike URL, documentURI is available on all types of documents.</p>\n</blockquote>\n<p>So theoretically, only <code>DocumentUri</code> is guaranteed to always return a value.</p>\n<h2 id="how-can-a-set-of-urls-from-be-extracted-from-an-html-document-using-linq%3F">How can a set of URLs from be extracted from an HTML document using LINQ?</h2>\n<p>Let\'s say the URLs can always be found in standard anchor links (<code>a</code>). One possible way is to use</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">var</span> links = document\n    .Links\n    .OfType&lt;IHtmlAnchorElement&gt;()\n    .Select(e =&gt; e.Href)\n    .Where(h =&gt; h.Contains(keyword));\n</code></pre>\n<p>Depending on our criteria we may use different LINQ statements (or at least a different <code>Where</code> clause).</p>\n<h2 id="how-to-specify-an-input-file-to-dom-of-%3Cinput-type%3D\'file\'%3E%3F">How to specify an input file to DOM of <code>&lt;input type=\'file\'&gt;</code>?</h2>\n<p>Every <code>IHtmlInputElement</code> has a <code>Files</code> property that can be used to add files.</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">var</span> input = document.QuerySelector&lt;IHtmlInputElement&gt;(<span class="hljs-string">&quot;input[type=file][name=myInputFile]&quot;</span>);\ninput?.Files.Add(file);\n</code></pre>\n<p>In the previously used example the file variable refers to any IFile instance. AngleSharp is a PCL does not come with a proper implementation out of the box, however, a simple one may look like:</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">class</span> <span class="hljs-title">FileEntry</span> : <span class="hljs-title">IFile</span>\n{\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> String _fileName;\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Stream _content;\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> String _type;\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> DateTime _modified;\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileEntry</span>(<span class="hljs-params">String fileName, String type, Stream content</span>)</span>\n    {\n        _fileName = fileName;\n        _type = type;\n        _content = content;\n        _modified = DateTime.Now;\n    }\n\n    <span class="hljs-keyword">public</span> Stream Body\n    {\n        <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> _content; }\n    }\n\n    <span class="hljs-keyword">public</span> Boolean IsClosed\n    {\n        <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> _content.CanRead == <span class="hljs-literal">false</span>; }\n    }\n\n    <span class="hljs-keyword">public</span> DateTime LastModified\n    {\n        <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> _modified; }\n    }\n\n    <span class="hljs-keyword">public</span> Int32 Length\n    {\n        <span class="hljs-keyword">get</span>\n        {\n            <span class="hljs-keyword">return</span> (Int32)_content.Length;\n        }\n    }\n\n    <span class="hljs-keyword">public</span> String Name\n    {\n        <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> _fileName; }\n    }\n\n    <span class="hljs-keyword">public</span> String Type\n    {\n        <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> _type; }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Close</span>(<span class="hljs-params"></span>)</span>\n    {\n        _content.Close();\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>(<span class="hljs-params"></span>)</span>\n    {\n        _content.Dispose();\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> IBlob <span class="hljs-title">Slice</span>(<span class="hljs-params">Int32 start = <span class="hljs-number">0</span>, Int32 end = Int32.MaxValue, String contentType = <span class="hljs-literal">null</span></span>)</span>\n    {\n        <span class="hljs-keyword">var</span> ms = <span class="hljs-keyword">new</span> MemoryStream();\n        _content.Position = start;\n        <span class="hljs-keyword">var</span> buffer = <span class="hljs-keyword">new</span> Byte[Math.Max(<span class="hljs-number">0</span>, Math.Min(end, _content.Length) - start)];\n        _content.Read(buffer, <span class="hljs-number">0</span>, buffer.Length);\n        ms.Write(buffer, <span class="hljs-number">0</span>, buffer.Length);\n        _content.Position = <span class="hljs-number">0</span>;\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FileEntry(_fileName, _type, ms);\n    }\n}\n</code></pre>\n<p>A more sophisticated one would auto-determine the MIME type and have constructor overloads to allow passing in (local) file paths etc.</p>\n<h2 id="how-to-parse-text-from-anonymous-block%3F">How to parse text from anonymous block?</h2>\n<p>Text is modeled as a <code>TextNode</code>, it is a type of node beside element, comment node, processing instruction, etc. That\'s why <code>NextElementSibling</code> you tried didn\'t include the text in the result since it intended to return elements only, as the name suggests.</p>\n<p>You can get text nodes located directly within product div by traversing through the div\'s <code>ChildNodes</code> and then filter by <code>NodeType</code>, for example:</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">var</span> products = document.QuerySelectorAll(<span class="hljs-string">&quot;div.product&quot;</span>);\n\n<span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> product <span class="hljs-keyword">in</span> products)\n{\n    <span class="hljs-keyword">var</span> productTitle = product.ChildNodes\n        .First(o =&gt; o.NodeType == NodeType.Text &amp;&amp; o.TextContent.Trim() != <span class="hljs-string">&quot;&quot;</span>);\n    Console.WriteLine(productTitle.TextContent.Trim());\n}\n</code></pre>\n<p>Notice that newlines between elements are also text nodes, so we need to filter those out.</p>\n<h2 id="how-to-produce-self-closing-tags%3F">How to produce self-closing tags?</h2>\n<p>Given the following usage scenario:</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">var</span> context = BrowsingContext.New();\n<span class="hljs-keyword">var</span> document = <span class="hljs-keyword">await</span> context.OpenNewAsync();\n\n<span class="hljs-keyword">var</span> tag = document.CreateElement(<span class="hljs-string">&quot;customTag&quot;</span>);\ntag.SetAttribute(<span class="hljs-string">&quot;attr&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>);\ntag.AsSelfClosing();\n\nConsole.WriteLine(tag.OuterHtml);\ntag.ToHtml(Console.Out, CustomHtmlMarkupFormatter.Instance);\n</code></pre>\n<p>We get the following output:</p>\n<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">customtag</span> <span class="hljs-attr">attr</span>=<span class="hljs-string">&quot;x&quot;</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">customtag</span> <span class="hljs-attr">attr</span>=<span class="hljs-string">&quot;x&quot;</span> /&gt;</span>\n</code></pre>\n<p>There are two places where you can work some stuff in to achieve such thing.</p>\n<ul>\n<li><code>readonly NodeFlags Node._flags</code>: Keep in mind that this field, its property and the host class are all not exposed. So you would need to some dirty hack to get the job one. Also, the default formatter <code>HtmlMarkupFormatter</code> use only <code>&gt;</code>, and not <code>/&gt;</code>.</li>\n<li>Create your own <code>IMarkupFormatter</code>.</li>\n</ul>\n<p>Here is a solution that uses both mentioned points.</p>\n<p>Let\'s start with some dirty hack:</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ElementExtensions</span>\n{\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AsSelfClosing</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> IElement element</span>)</span>\n    {\n        <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> SelfClosing = <span class="hljs-number">0x1</span>;\n\n        <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">typeof</span>(IElement).Assembly.GetType(<span class="hljs-string">&quot;AngleSharp.Dom.Node&quot;</span>);\n        <span class="hljs-keyword">var</span> field = type.GetField(<span class="hljs-string">&quot;_flags&quot;</span>, BindingFlags.Instance | BindingFlags.NonPublic);\n\n        <span class="hljs-keyword">var</span> flags = (<span class="hljs-built_in">uint</span>)field.GetValue(element);\n        flags |= SelfClosing;\n        field.SetValue(element, Enum.ToObject(field.FieldType, flags));\n    }\n}\n</code></pre>\n<p>Now let\'s roll out our own markup formatter:</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CustomHtmlMarkupFormatter</span> : <span class="hljs-title">IMarkupFormatter</span>\n{\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> CustomHtmlMarkupFormatter Instance = <span class="hljs-keyword">new</span> CustomHtmlMarkupFormatter();\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">Text</span>(<span class="hljs-params">String text</span>)</span> =&gt; HtmlMarkupFormatter.Instance.Text(text);\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">Comment</span>(<span class="hljs-params">IComment comment</span>)</span> =&gt; HtmlMarkupFormatter.Instance.Comment(comment);\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">Processing</span>(<span class="hljs-params">IProcessingInstruction processing</span>)</span> =&gt; HtmlMarkupFormatter.Instance.Processing(processing);\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">Doctype</span>(<span class="hljs-params">IDocumentType doctype</span>)</span> =&gt; HtmlMarkupFormatter.Instance.Doctype(doctype);\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">CloseTag</span>(<span class="hljs-params">IElement element, Boolean selfClosing</span>)</span> =&gt; HtmlMarkupFormatter.Instance.CloseTag(element, selfClosing);\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">Attribute</span>(<span class="hljs-params">IAttr attribute</span>)</span> =&gt; HtmlMarkupFormatter.Instance.Attribute(attribute);\n\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">OpenTag</span>(<span class="hljs-params">IElement element, Boolean selfClosing</span>)</span>\n    {\n        <span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> StringBuilder();\n        temp.Append(<span class="hljs-string">&#x27;&lt;&#x27;</span>);\n\n        <span class="hljs-keyword">if</span> (!String.IsNullOrEmpty(element.Prefix))\n        {\n            temp.Append(element.Prefix).Append(<span class="hljs-string">&#x27;:&#x27;</span>);\n        }\n\n        temp.Append(element.LocalName);\n\n        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> attribute <span class="hljs-keyword">in</span> element.Attributes)\n        {\n            temp.Append(<span class="hljs-string">&quot; &quot;</span>).Append(<span class="hljs-keyword">this</span>.Attribute(attribute));\n        }\n\n        temp.Append(selfClosing ? <span class="hljs-string">&quot; /&gt;&quot;</span> : <span class="hljs-string">&quot;&gt;&quot;</span>);\n\n        <span class="hljs-keyword">return</span> temp.ToString();\n    }\n}\n</code></pre>\n<h2 id="how-to-use-anglesharp-in-unity%3F">How to use AngleSharp in Unity?</h2>\n<p>The following steps will allow AngleSharp to be fully integrated from NuGet into a Unity solution.</p>\n<ol>\n<li>Get the AngleSharp NuGet package from the VS NuGet Package manager.</li>\n<li>Build the solution (Build -&gt; Build Solution)</li>\n<li>Copy the &quot;netstandard2.0&quot; folder into the unity Assets folder. You can find it in &quot;[your project]PackagesAngleSharp.0.11.0&quot;. Version may vary.</li>\n</ol>\n<p>More details why this is the current approach can be found in this <a href="https://stackoverflow.com/questions/53447595/nuget-packages-in-unity">StackOverflow</a> answer. This behavior is known and the advised approach is to use VS for installing the NuGet (which resolves the .NET Standard 2.0 dependency as it should be).</p>\n<p>The answer was taken from a discussion in issue #774.</p>\n<h2 id="how-to-create-elements-from-a-string%3F">How to create elements from a string?</h2>\n<p>This is possible using a document fragment.</p>\n<p>There are multiple possibilities how to use a document fragment, one way would be to use fragment parsing for generating a node list in the right (element) context:</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">var</span> context = BrowsingContext.New(Configuration.Default);\n<span class="hljs-keyword">var</span> document = <span class="hljs-keyword">await</span> context.OpenAsync(r =&gt; r.Content(<span class="hljs-string">&quot;&lt;div id=app&gt;&lt;div&gt;Some already available content...&lt;/div&gt;&lt;/div&gt;&quot;</span>));\n<span class="hljs-keyword">var</span> app = document.QuerySelector(<span class="hljs-string">&quot;#app&quot;</span>);\n<span class="hljs-keyword">var</span> parser = context.GetService&lt;IHtmlParser&gt;();\n<span class="hljs-keyword">var</span> nodes = parser.ParseFragment(<span class="hljs-string">&quot;&lt;div id=&#x27;div1&#x27;&gt;hi&lt;p&gt;world&lt;/p&gt;&lt;/div&gt;&quot;</span>, app);\napp.Append(nodes.ToArray());\n</code></pre>\n<p>The example shows how nodes can be created in the context of a certain element (#app in this case) and that the behavior is different than, e.g., using <code>InnerHtml</code>, which would remove existing nodes.</p>\n<h2 id="can-i-retrieve-the-positions-of-elements-in-the-source-code%3F">Can I retrieve the positions of elements in the source code?</h2>\n<p>By default AngleSharp will throw away the &quot;tokens&quot; that associate the element with a position in the source code. This is mostly done due to the required memory consumption. The tag tokens transport not only the position, but also some additional fields like the name, flags and other meta information, as well as attributes. These tokens, however, can be preserved.</p>\n<p>Currently, there are two ways to do this (both accessible via the <code>HtmlParserOptions</code>).</p>\n<ol>\n<li>For one-time scenarios during parsing the <code>OnCreated</code> callback can be used. The first argument is the <code>IElement</code> instance. The second argument received by the callback is a <code>TextPosition</code> value.</li>\n<li>For retrieval at a later point in time the <code>IsKeepingSourceReferences</code> option could be set to <code>true</code>. This way the <code>SourceReference</code> property of all parser-created <code>IElement</code> instances will be non-null. Currently, the referenced <code>ISourceReference</code> only contains a <code>Position</code> property.</li>\n</ol>\n<p>In code for option 1 this looks as follows:</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">var</span> bodyPos = TextPosition.Empty;\n<span class="hljs-keyword">var</span> parser = <span class="hljs-keyword">new</span> HtmlParser(<span class="hljs-keyword">new</span> HtmlParserOptions\n{\n    OnCreated = (IElement element, TextPosition position) =&gt;\n    {\n        <span class="hljs-keyword">if</span> (element.TagName == <span class="hljs-string">&quot;BODY&quot;</span>)\n        {\n            bodyPos = position;\n        }\n    },\n});\n<span class="hljs-keyword">var</span> document = parser.ParseDocument(<span class="hljs-string">&quot;&lt;!doctype html&gt;&lt;body&gt;&quot;</span>);\n</code></pre>\n<p>The code for option 2 looks as follows:</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">var</span> parser = <span class="hljs-keyword">new</span> HtmlParser(<span class="hljs-keyword">new</span> HtmlParserOptions\n{\n    IsKeepingSourceReferences = <span class="hljs-literal">true</span>,\n});\n<span class="hljs-keyword">var</span> document = parser.ParseDocument(<span class="hljs-string">&quot;&lt;!doctype html&gt;&lt;body&gt;&quot;</span>);\n<span class="hljs-keyword">var</span> bodyPos = document.Body.SourceReference.Position;\n</code></pre>\n<p>In both cases the position we care about will be stored in <code>bodyPos</code>.</p>\n<p><strong>Remark</strong>: As <code>SourceReference</code> may be empty (e.g., when we omit the provided option or if we select an element that came in <em>after</em> parsing) we advise of using <code>SourceReference?.Position</code>, where we would end up with a <code>Nullable&lt;TextPosition&gt;</code>. Ideally, we then just use <code>TextPosition.Empty</code> as the fallback, e.g., in the code above:</p>\n<pre><code class="hljs language-cs"><span class="hljs-keyword">var</span> bodyPos = document.Body.SourceReference?.Position ?? TextPosition.Empty;\n</code></pre>\n',l=function(){return s.createElement(e.ContentPage,null,s.createElement(e.PageContent,{meta:{title:"FAQ"}},s.createElement(e.Markdown,{content:o,link:t,editLabel:"Edit on GitHub"})))};exports.default=l;
},{"react":"kvyv","../../scripts/components":"s4fr"}]},{},[], null)
//# sourceMappingURL=/general-05-Questions.85fece4c.js.map